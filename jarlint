#!/usr/bin/perl

use strict;
use vars;
use English;

use Digest::MD5;

$OUTPUT_RECORD_SEPARATOR = "\n";

my($classpath,@classpath,%hashes,@nils,%names,%roots,%dupes,$dupes,@newcp,%binary_dupes);

if(@ARGV > 0) {
    my $cp = shift();
    if(-e $cp) {
	local(*F);
	open(F,$cp) || die "Couldn't open '$cp': $!\n";
	while(<F>) {
	    chomp();
	    next if (/^#/ || $_ !~ /\w/);
	    s/.*CLASSPATH=//i;
	    s/^\s*//;
	    s/\s*$//;
	    s/;$//;
	    $classpath = $_;
	    last;
	}
	close(F);
	$_ = ""; # need this so you can just say print (no args) later. 
    } else {
	$classpath = $cp;
    }
} else {
    $classpath = $ENV{'CLASSPATH'};
}	    
@classpath = split(/:/,$classpath);

sub hashit($) {
    my($file) = @_;
    my($md5);
    local(*F);
    open(F,$file) || die "Could not open file '$file': $!\n";
    $md5 = Digest::MD5->new;
    $md5->addfile(*F);
    return $md5->hexdigest();
}

sub h($$) {
    my($msg,$char) = @_;
    return $msg . "\n" . $char x length($msg);
}

sub h1($) {
    my ($msg) = @_;
    h($msg,'=');
}

sub h2($) {
    my($msg) = @_;
    h($msg,'-');
}

sub code($) {
    my($c) = @_;
    " " x 4 . $c;
}

for my $entry (@classpath) {
    $dupes{$entry}++;
    push(@newcp,$entry);
    if(! -e $entry) {
	push(@nils,$entry);
	pop(@newcp);
    } elsif (-f $entry) {
	if($dupes{$entry} == 1) {
	    my $hash = hashit($entry);
	    my $root;
	    if ($hashes{$hash}) {
		$binary_dupes{$entry}++;
		foreach my $other (@{$hashes{$hash}}) {
		    $binary_dupes{$other}++;
		}
		pop(@newcp);
	    }
	    push(@{$hashes{$hash}},$entry);
	    my ($basename) = $entry =~ m|.*/(.*)|;
	    push(@{$names{$basename}}, $entry);
	    if($basename =~ /(.*?)[0-9\.]+.(jar|zip)/i) {
		$root = $1;
		$root =~ s/[-\.]$//;
	    } else {
		($root) = $basename =~ /(.*)\.(jar|zip)/i;
	    }
	    push(@{$roots{$root}},$entry);
	} else { # a dupe file
	    $dupes++;
	    pop(@newcp);
	}
    } elsif (-d $entry) {
	if($dupes{$entry} > 1) {
	    pop(@newcp);
	    $dupes++;
	}
    }
}

print;
print;
print h1("The Low-Hanging Fruit");
print;

if(@nils > 0) {
    print h2("The following classpath elements do not exist, and can safely be removed");
    foreach my $nil (sort(@nils)) {
	print code "$nil";
    }
    print;
}

if($dupes > 0) {
    print h2("The following classpath elements appear more than one time -- you can safely prune entries 2+");
    while(my($k,$v) = each(%dupes)) {
	if($v > 1) {
	    print code "$k";
	}
    }
    print;
}

if(%binary_dupes > 0) {
    print h2("The following jar files appear to be binary-identical; you can safely remove instances 2+");
    foreach my $hash (keys(%hashes)) {
	if(@{$hashes{$hash}} > 1) {
	    foreach(@{$hashes{$hash}}) {
		print code "$_";
	    }
	    print;
	}
    }
}
    
print;
print h2("Safe new classpath");
my $count = @nils + $dupes;
my $pct = ($count / @classpath) * 100;
printf("By my estimation, you can trim at least %d elements from your classpath right off the bat, a %0.0f%% reduction in its length. You can pretty safely try this:\n",$count,$pct);
print;
print code "CLASSPATH=" . join(':', @newcp);

print;
print;
print h1("The Hard Part");
print;

{ 
    my(@jars);
    foreach my $name (sort(keys(%names))) {
	my @list = @{$names{$name}}; 
	if(@list > 1) {
	    foreach(@list) {
		push(@jars,$_) unless($binary_dupes{$_});
	    }
	}
    }

    if(@jars > 0) {
	print h2("The following jars exist in more than one directory, and are binary-different. This is bad, and requires manual sleuthing.");
	foreach my $name (sort(keys(%names))) {
	    my @list = @{$names{$name}}; 
	    if(@list > 1) {
		foreach(@list) {
		    print code "$_" unless($binary_dupes{$_});
		}
		print;
	    }
	}
	print;
    }
}

{ 
    my(@jars);
    foreach my $root (sort(keys(%roots))) {
	my @list = @{$roots{$root}};
	if(@list > 1 && grep(/\d\.\d/,@list) > 0) {
	    foreach (@list) {
		push(@jars,$_);
	    }
	}
    }

    if(@jars > 0) {
	print h2("The following jars look like they're different versions of the same package. This is a little sketchy, and is probably worth checking out.");
	foreach my $root (sort(keys(%roots))) {
	    my @list = @{$roots{$root}};
	    if(@list > 1 && grep(/\d\.\d/,@list) > 0) {
		foreach (@list) {
		    print code "$_";
		}
		print;
	    }
	}
    }
}

